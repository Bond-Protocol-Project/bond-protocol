{
  "_format": "hh3-sol-build-info-1",
  "id": "3730540ab1d98da067d3c7183bb5a357aa7b5834",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "publicSourceNameMap": {
    "contracts/protocol/BondPool.sol": "contracts/protocol/BondPool.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "viaIR": true,
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "forge-std/=npm/forge-std@1.9.4/src/",
        "@account-abstraction/=node_modules/@account-abstraction/",
        "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
        "@chainlink/contracts/=node_modules/@chainlink/contracts/",
        "@chainlink/contracts-ccip/=node_modules/@chainlink/contracts-ccip/",
        "@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.3.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.3.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.3.0/"
      ]
    },
    "sources": {
      "contracts/interfaces/IBondPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport {DataTypes} from \"../libraries/DataTypes.sol\";\r\n\r\n/**\r\n * @title IPool\r\n * @dev Interface of the liquidity pool contract.\r\n */\r\ninterface IBondPool {\r\n    /**\r\n     * @dev Creates a new liquidity pool with the specified parameters, also create the lp token for the pool.\r\n     * @param _poolId Pool ID.\r\n     * @param _underlyingToken Address of the underlying token.\r\n     * @param _supplyTokenName Name of the supply token.\r\n     * @param _supplyTokenSymbol Symbol of the supply token.\r\n     */\r\n    function createPool(\r\n        uint64 _poolId,\r\n        address _underlyingToken,\r\n        string memory _supplyTokenName,\r\n        string memory _supplyTokenSymbol\r\n    ) external returns (DataTypes.PoolData memory _pool);\r\n\r\n    /**\r\n     * @dev Allows a user to supply tokens to the pool and receive supply tokens in return.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to supply.\r\n     * @param _onBehalfOf The address on behalf of which the tokens are supplied.\r\n     */\r\n    function supply(\r\n        uint64 _poolId,\r\n        uint256 _amount,\r\n        address _onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows a user to withdraw tokens from the pool.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to withdraw.\r\n     * @param _onBehalfOf The address on behalf of which the tokens are withdrawn.\r\n     */\r\n    function withdraw(\r\n        uint64 _poolId,\r\n        uint256 _amount,\r\n        address _onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Handles the receipt of tokens from the bridge and performs necessary actions.\r\n     * @param _poolId Destination pool ID.\r\n     * @param _fee Fee associated with the transaction.\r\n     */\r\n    function handlePoolIncentive(uint64 _poolId, uint256 _fee) external;\r\n\r\n    /**\r\n     * @dev Updates user incentives for a specific pool.\r\n     * @param _user User address.\r\n     * @param _poolId Pool ID.\r\n     */\r\n    function updateUserIncentives(address _user, uint64 _poolId) external;\r\n\r\n    /**\r\n     * @dev Retrieves data for a specific pool.\r\n     * @param _poolId Pool ID.\r\n     * @return _pool Pool data structure.\r\n     */\r\n    function getPool(\r\n        uint64 _poolId\r\n    ) external view returns (DataTypes.PoolData memory _pool);\r\n\r\n    /**\r\n     * @dev Retrieves user data for a specific account.\r\n     * @param _account User address.\r\n     * @return _user User data structure.\r\n     */\r\n    function getUserData(\r\n        address _account\r\n    ) external view returns (DataTypes.UserData memory _user);\r\n}\r\n"
      },
      "contracts/interfaces/IBondProtocol.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport {DataTypes} from \"../libraries/DataTypes.sol\";\r\n\r\n/**\r\n * @title IBondProtocol\r\n * @dev Interface of the protocol main contract.\r\n */\r\ninterface IBondProtocol {\r\n    /**\r\n     * @notice This function sends the intent message to every required chain\r\n     * @dev This is the entry function to send an intent request\r\n     * @param _intentData the intent bytes to be executed\r\n     */\r\n    function submitIntent(bytes memory _intentData) external;\r\n\r\n    /**\r\n     * @notice This function just simulates the submitIntent function above and get required fees to process the intent passed\r\n     * @dev simulate submiting intent and get fees\r\n     * @param _intentData the intent bytes data\r\n     */\r\n    function getFees(bytes memory _intentData) external;\r\n\r\n    /**\r\n     * @notice This function emits event that notifies solvers to build next required userop\r\n     * @dev This function is called by _ccipReceive from the bridge contract, data is to be consumed by the protocol\r\n     * @param _data this is the CCIP bridged message (DataTypes.BridgeData).\r\n     * @param srcBridgedChainSelector The source chain selector from CCIP\r\n     */\r\n    function confirmIncomingIntent(\r\n        bytes memory _data,\r\n        uint64 srcBridgedChainSelector\r\n    ) external;\r\n\r\n    /**\r\n     * @dev This function is called by account to settle intent destination chain\r\n     * @param _intentId intent Id to interact with\r\n     * @param _executor this is the solver that built the userOp\r\n     */\r\n    function settleIntentDestChain(\r\n        bytes32 _intentId,\r\n        address _executor\r\n    ) external;\r\n\r\n    /**\r\n     * @dev This function is called by account to settle the solver that build the userOp to run the intent destination datas\r\n     * @param _intentId intent Id to interact with\r\n     * @param _executor this is the solver that built the userOp\r\n     */\r\n    function settleIntentDestExecutor(\r\n        bytes32 _intentId,\r\n        address _executor\r\n    ) external;\r\n\r\n    /**\r\n     * @dev helper function to check if intent has been used on this chain\r\n     * @param _intentId Intent id to check\r\n     */\r\n    function isIntentExecuted(bytes32 _intentId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Creates a new pool with the specified parameters.\r\n     * @param _poolId Pool ID.\r\n     * @param _underlyingToken Address of the underlying token.\r\n     * @param _supplyTokenName Name of the supply token.\r\n     * @param _supplyTokenSymbol Symbol of the supply token.\r\n     */\r\n    function createPool(\r\n        uint64 _poolId,\r\n        address _underlyingToken,\r\n        string memory _supplyTokenName,\r\n        string memory _supplyTokenSymbol\r\n    ) external returns (DataTypes.PoolData memory);\r\n\r\n    /**\r\n     * @notice Retrieves pool data for a given pool ID.\r\n     * @param _poolId Pool ID.\r\n     * @return Pool data structure.\r\n     */\r\n    function getPool(\r\n        uint64 _poolId\r\n    ) external view returns (DataTypes.PoolData memory);\r\n\r\n    /**\r\n     * @dev retreive intent data\r\n     * @param _intentId intent Id to be retreived\r\n     */\r\n    function getIntent(\r\n        bytes32 _intentId\r\n    ) external view returns (DataTypes.IntentData memory);\r\n\r\n    /**\r\n     * @dev checks if all source chains in intent has settled the destination chain\r\n     * @param _intentId intent Id ro be checked\r\n     */\r\n    function isIntentDstChainFullySettled(\r\n        bytes32 _intentId\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev helper function to check if intent is valid\r\n     * @param _intentId Intent id to check\r\n     */\r\n    function isIntentValid(\r\n        bytes32 _intentId,\r\n        address sender_\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Retreive current intent nonce for sender\r\n     * @param _sender the sender to retreive intent nonce for\r\n     */\r\n    function getNonce(address _sender) external view returns (uint64);\r\n\r\n    /**\r\n     * @dev Admin only function to initailize protocol bridge address\r\n     * @param bridge_ bridge address\r\n     */\r\n    function initializeBridge(address bridge_) external;\r\n\r\n    /**\r\n     * @dev Admin only function to initailize protocol pool address\r\n     * @param pool_ pool address\r\n     */\r\n    function initializePool(address pool_) external;\r\n}\r\n"
      },
      "contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC-20 standard as defined in the ERC.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
      },
      "contracts/interfaces/ILPTokenERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @dev Interface of the ERC20 liquidity pool token contract.\r\n */\r\ninterface ILPTokenERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Mint(address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Burn(address indexed account, uint256 value);    \r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the default value returned by this function, unless\r\n     * it's overridden.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function getDecimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account` without scaled incentives.\r\n     */\r\n    function unscaledBalanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev mints a `value` amount of lp tokens to `to`\r\n     *\r\n     * Emits a {Mint} event.\r\n     */\r\n    function mint(address to, uint256 value) external;\r\n    \r\n    /**\r\n     * @dev burns a `value` amount of lp tokens from `account`\r\n     *\r\n     * Emits a {Burn} event.\r\n     */\r\n    function burn(address account, uint256 value) external;\r\n}\r\n"
      },
      "contracts/interfaces/ILPTokenFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface ILPTokenFactory {\r\n    function createSupplyToken(\r\n        uint64 _poolId,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) external returns (address tokenAddress);\r\n}\r\n"
      },
      "contracts/libraries/DataTypes.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title DataTypes\r\n * @dev Library defining common data structures used in protocol contracts.\r\n */\r\nlibrary DataTypes {\r\n    /**\r\n     * @dev Data structure representing intent destination data to be called by\r\n     *      account in destination chain.\r\n     */\r\n    struct IntentDstData {\r\n        address target;\r\n        uint256 value;\r\n        bytes data;\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about an intent.\r\n     */\r\n    struct IntentData {\r\n        address sender;\r\n        uint64 initChainSenderNonce;\r\n        uint64 initChainId;\r\n        uint64 poolId;\r\n        uint64[] srcChainIds;\r\n        uint256[] srcAmounts;\r\n        uint64 dstChainId;\r\n        bytes dstDatas; // IntentDstData[]\r\n        uint256 expires;\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing a message used in cross-chain bridging.\r\n     */\r\n    struct BridgeData {\r\n        bytes32 intentId; // protocol bridge message data\r\n        bytes intentData; // bridged protocol intent information\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing a message used in cross-chain bridging.\r\n     */\r\n    struct BridgeMsgData {\r\n        bool isBatch;\r\n        bytes bridgeData; // bridge data information\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about a liquidity pool.\r\n     */\r\n    struct PoolData {\r\n        uint64 poolId; // Unique identifier for the pool.\r\n        address underlyingToken; // Address of the underlying token for the pool.\r\n        address supplyToken; // Address of the supply token for the pool.\r\n        uint256 unclaimedProfit; // Accumulated unclaimed profit in the pool.\r\n        uint256 currentIndex; // Current index used for incentive calculations.\r\n        // uint256 lastUpdateTimestamp; // Timestamp of the last update.\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about a user's interaction with a pool.\r\n     */\r\n    struct UserData {\r\n        uint256 currentPoolIndex; // User's current index in the pool.\r\n        // uint256 lastUpdateTimestamp; // Timestamp of the last update.\r\n    }\r\n    \r\n    // BELOW TYPES ARE NOT BEING USED FOR NOW\r\n\r\n    /**\r\n     * @dev enum representing intent token type.\r\n     */\r\n    enum IntentTokenType {\r\n        ERC20,\r\n        ERC1155,\r\n        ERC721\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about the chain.\r\n     */\r\n    struct ChainData {\r\n        address protocolAddress;\r\n        uint64 ccipChainselector;\r\n        uint32 subnetId;\r\n        address middlewareAddress;\r\n    }\r\n}\r\n"
      },
      "contracts/protocol/BondPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport {IBondProtocol} from \"../interfaces/IBondProtocol.sol\";\r\nimport {IBondPool} from \"../interfaces/IBondPool.sol\";\r\nimport {DataTypes} from \"../libraries/DataTypes.sol\";\r\nimport {ILPTokenERC20} from \"../interfaces/ILPTokenERC20.sol\";\r\nimport {ILPTokenFactory} from \"../interfaces/ILPTokenFactory.sol\";\r\nimport {IERC20} from \"../interfaces/IERC20.sol\";\r\n\r\ncontract BondPool is IBondPool, ReentrancyGuard {\r\n    //\r\n    // Main contract address users interact with (users interact with the pool from the protocol contract)\r\n    IBondProtocol public immutable protocol;\r\n    // Mapping to store pool data based on pool IDs\r\n    mapping(uint64 poolId => DataTypes.PoolData) private poolData;\r\n    // Mapping to store user data based on user addresses\r\n    mapping(address => DataTypes.UserData) private userData;\r\n    // Liquidity pool token factory address\r\n    address public immutable tokenFactory;\r\n\r\n    // Modifier to restrict functions to be called only by the router\r\n    modifier onlyProtocol() {\r\n        require(msg.sender == address(protocol), \"Caller must be Router.\");\r\n        _;\r\n    }\r\n\r\n    // Modifier to restrict functions to be called only by the supply token of a pool\r\n    modifier onlySupplyToken(uint64 _poolId) {\r\n        require(\r\n            msg.sender == getPool(_poolId).supplyToken,\r\n            \"Caller must be pool token\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor initializes the router address.\r\n     * @param _protocol The address of the router contract.\r\n     */\r\n    constructor(address _protocol, address _factory) {\r\n        protocol = IBondProtocol(_protocol);\r\n        tokenFactory = _factory;\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new pool with the specified parameters.\r\n     * @param _poolId Pool ID.\r\n     * @param _underlyingToken Address of the underlying token.\r\n     * @param _supplyTokenName Name of the supply token.\r\n     * @param _supplyTokenSymbol Symbol of the supply token.\r\n     */\r\n    function createPool(\r\n        uint64 _poolId,\r\n        address _underlyingToken,\r\n        string memory _supplyTokenName,\r\n        string memory _supplyTokenSymbol\r\n    ) external onlyProtocol returns (DataTypes.PoolData memory _pool) {\r\n        require(\r\n            address(poolData[_poolId].underlyingToken) == address(0x0),\r\n            \"Pool already created\"\r\n        );\r\n        address _supplyToken = ILPTokenFactory(tokenFactory).createSupplyToken(\r\n            _poolId,\r\n            _supplyTokenName,\r\n            _supplyTokenSymbol\r\n        );\r\n        _pool.poolId = _poolId;\r\n        _pool.underlyingToken = _underlyingToken;\r\n        _pool.supplyToken = _supplyToken;\r\n        poolData[_poolId] = _pool;\r\n        return _pool;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a user to supply tokens to the pool and receive supply tokens in return.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to supply.\r\n     * @param _onBehalfOf The address on behalf of which the tokens are supplied.\r\n     */\r\n    function supply(\r\n        uint64 _poolId,\r\n        uint256 _amount,\r\n        address _onBehalfOf\r\n    ) external nonReentrant onlyProtocol {\r\n        _updateUserIncentives(_onBehalfOf, _poolId);\r\n        ILPTokenERC20(getPool(_poolId).supplyToken).mint(_onBehalfOf, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a user to withdraw tokens from the pool by burning supply tokens.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to withdraw.\r\n     * @param _onBehalfOf The address on behalf of which the tokens are withdrawn.\r\n     */\r\n    function withdraw(\r\n        uint64 _poolId,\r\n        uint256 _amount,\r\n        address _onBehalfOf\r\n    ) external nonReentrant onlyProtocol {\r\n        require(\r\n            IERC20(getPool(_poolId).underlyingToken).balanceOf(address(this)) >=\r\n                _amount,\r\n            \"Not enough token in pool\"\r\n        );\r\n        _updateUserIncentives(_onBehalfOf, _poolId);\r\n        ILPTokenERC20(getPool(_poolId).supplyToken).burn(_onBehalfOf, _amount);\r\n        bool _transfer_success = IERC20(getPool(_poolId).underlyingToken)\r\n            .transfer(_onBehalfOf, _amount);\r\n        require(_transfer_success, \"Operation failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the user's incentives for a specific pool.\r\n     * @param _user User address.\r\n     * @param _poolId Pool ID.\r\n     */\r\n    function updateUserIncentives(\r\n        address _user,\r\n        uint64 _poolId\r\n    ) external nonReentrant onlySupplyToken(_poolId) {\r\n        _updateUserIncentives(_user, _poolId);\r\n    }\r\n\r\n    /**\r\n     * @notice Handles the receipt of tokens from the bridge and performs necessary actions.\r\n     * @param _poolId pool ID to handle.\r\n     * @param _fee Fee associated with the transaction.\r\n     */\r\n    function handlePoolIncentive(\r\n        uint64 _poolId,\r\n        uint256 _fee\r\n    )\r\n        external\r\n        nonReentrant\r\n        onlyProtocol\r\n    {\r\n        DataTypes.PoolData memory _pool = getPool(_poolId);\r\n        uint256 _index = (_fee *\r\n            (10 ** ILPTokenERC20(_pool.supplyToken).getDecimals())) /\r\n            (ILPTokenERC20(_pool.supplyToken).totalSupply());\r\n        _pool.currentIndex = _pool.currentIndex + _index;\r\n        _pool.unclaimedProfit = _pool.unclaimedProfit + _fee;\r\n        poolData[_poolId] = _pool;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to update user incentives for a specific pool.\r\n     * @param _user User address.\r\n     * @param _poolId Pool ID.\r\n     */\r\n    function _updateUserIncentives(address _user, uint64 _poolId) private {\r\n        DataTypes.PoolData memory _pool = getPool(_poolId);\r\n        if (userData[_user].currentPoolIndex < _pool.currentIndex) {\r\n            uint256 _unclaimedUserProfit = ((_pool.currentIndex -\r\n                userData[_user].currentPoolIndex) *\r\n                ILPTokenERC20(_pool.supplyToken).unscaledBalanceOf(_user)) /\r\n                (10 ** ILPTokenERC20(_pool.supplyToken).getDecimals());\r\n\r\n            userData[_user].currentPoolIndex = _pool.currentIndex;\r\n            _pool.unclaimedProfit =\r\n                _pool.unclaimedProfit -\r\n                _unclaimedUserProfit;\r\n            poolData[_poolId] = _pool;\r\n            ILPTokenERC20(_pool.supplyToken).mint(_user, _unclaimedUserProfit);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves user data for a given user address.\r\n     * @param _account User address.\r\n     * @return User data structure.\r\n     */\r\n    function getUserData(\r\n        address _account\r\n    ) external view returns (DataTypes.UserData memory) {\r\n        return userData[_account];\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves pool data for a given pool ID.\r\n     * @param _poolId Pool ID.\r\n     * @return Pool data structure.\r\n     */\r\n    function getPool(\r\n        uint64 _poolId\r\n    ) public view returns (DataTypes.PoolData memory) {\r\n        require(\r\n            poolData[_poolId].underlyingToken != address(0),\r\n            \"Invalid pool\"\r\n        );\r\n        return poolData[_poolId];\r\n    }\r\n\r\n    function getProtocol() external view returns(address) {\r\n        return address(protocol);\r\n    }\r\n}\r\n"
      },
      "node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      }
    }
  }
}