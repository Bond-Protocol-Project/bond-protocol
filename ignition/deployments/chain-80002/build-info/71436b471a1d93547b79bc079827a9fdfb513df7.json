{
  "_format": "hh3-sol-build-info-1",
  "id": "71436b471a1d93547b79bc079827a9fdfb513df7",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "publicSourceNameMap": {
    "contracts/protocol/BondBridge.sol": "contracts/protocol/BondBridge.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "viaIR": true,
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "forge-std/=npm/forge-std@1.9.4/src/",
        "@account-abstraction/=node_modules/@account-abstraction/",
        "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
        "@chainlink/contracts/=node_modules/@chainlink/contracts/",
        "@chainlink/contracts-ccip/=node_modules/@chainlink/contracts-ccip/",
        "@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.3.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.3.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.3.0/"
      ]
    },
    "sources": {
      "contracts/interfaces/IBondProtocol.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport {DataTypes} from \"../libraries/DataTypes.sol\";\r\n\r\n/**\r\n * @title IBondProtocol\r\n * @dev Interface of the protocol main contract.\r\n */\r\ninterface IBondProtocol {\r\n    /**\r\n     * @notice This function sends the intent message to every required chain\r\n     * @dev This is the entry function to send an intent request\r\n     * @param _intentData the intent bytes to be executed\r\n     */\r\n    function submitIntent(bytes memory _intentData) external;\r\n\r\n    /**\r\n     * @notice This function just simulates the submitIntent function above and get required fees to process the intent passed\r\n     * @dev simulate submiting intent and get fees\r\n     * @param _intentData the intent bytes data\r\n     */\r\n    function getFees(bytes memory _intentData) external;\r\n\r\n    /**\r\n     * @notice This function emits event that notifies solvers to build next required userop\r\n     * @dev This function is called by _ccipReceive from the bridge contract, data is to be consumed by the protocol\r\n     * @param _data this is the CCIP bridged message (DataTypes.BridgeData).\r\n     * @param srcBridgedChainSelector The source chain selector from CCIP\r\n     */\r\n    function confirmIncomingIntent(\r\n        bytes memory _data,\r\n        uint64 srcBridgedChainSelector\r\n    ) external;\r\n\r\n    /**\r\n     * @dev This function is called by account to settle intent destination chain\r\n     * @param _intentId intent Id to interact with\r\n     * @param _executor this is the solver that built the userOp\r\n     */\r\n    function settleIntentDestChain(\r\n        bytes32 _intentId,\r\n        address _executor\r\n    ) external;\r\n\r\n    /**\r\n     * @dev This function is called by account to settle the solver that build the userOp to run the intent destination datas\r\n     * @param _intentId intent Id to interact with\r\n     * @param _executor this is the solver that built the userOp\r\n     */\r\n    function settleIntentDestExecutor(\r\n        bytes32 _intentId,\r\n        address _executor\r\n    ) external;\r\n\r\n    /**\r\n     * @dev helper function to check if intent has been used on this chain\r\n     * @param _intentId Intent id to check\r\n     */\r\n    function isIntentExecuted(bytes32 _intentId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Creates a new pool with the specified parameters.\r\n     * @param _poolId Pool ID.\r\n     * @param _underlyingToken Address of the underlying token.\r\n     * @param _supplyTokenName Name of the supply token.\r\n     * @param _supplyTokenSymbol Symbol of the supply token.\r\n     */\r\n    function createPool(\r\n        uint64 _poolId,\r\n        address _underlyingToken,\r\n        string memory _supplyTokenName,\r\n        string memory _supplyTokenSymbol\r\n    ) external returns (DataTypes.PoolData memory);\r\n\r\n    /**\r\n     * @notice Retrieves pool data for a given pool ID.\r\n     * @param _poolId Pool ID.\r\n     * @return Pool data structure.\r\n     */\r\n    function getPool(\r\n        uint64 _poolId\r\n    ) external view returns (DataTypes.PoolData memory);\r\n\r\n    /**\r\n     * @dev retreive intent data\r\n     * @param _intentId intent Id to be retreived\r\n     */\r\n    function getIntent(\r\n        bytes32 _intentId\r\n    ) external view returns (DataTypes.IntentData memory);\r\n\r\n    /**\r\n     * @dev checks if all source chains in intent has settled the destination chain\r\n     * @param _intentId intent Id ro be checked\r\n     */\r\n    function isIntentDstChainFullySettled(\r\n        bytes32 _intentId\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev helper function to check if intent is valid\r\n     * @param _intentId Intent id to check\r\n     */\r\n    function isIntentValid(\r\n        bytes32 _intentId,\r\n        address sender_\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Retreive current intent nonce for sender\r\n     * @param _sender the sender to retreive intent nonce for\r\n     */\r\n    function getNonce(address _sender) external view returns (uint64);\r\n\r\n    /**\r\n     * @dev Admin only function to initailize protocol bridge address\r\n     * @param bridge_ bridge address\r\n     */\r\n    function initializeBridge(address bridge_) external;\r\n\r\n    /**\r\n     * @dev Admin only function to initailize protocol pool address\r\n     * @param pool_ pool address\r\n     */\r\n    function initializePool(address pool_) external;\r\n}\r\n"
      },
      "contracts/libraries/DataTypes.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title DataTypes\r\n * @dev Library defining common data structures used in protocol contracts.\r\n */\r\nlibrary DataTypes {\r\n    /**\r\n     * @dev Data structure representing intent destination data to be called by\r\n     *      account in destination chain.\r\n     */\r\n    struct IntentDstData {\r\n        address target;\r\n        uint256 value;\r\n        bytes data;\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about an intent.\r\n     */\r\n    struct IntentData {\r\n        address sender;\r\n        uint64 initChainSenderNonce;\r\n        uint64 initChainId;\r\n        uint64 poolId;\r\n        uint64[] srcChainIds;\r\n        uint256[] srcAmounts;\r\n        uint64 dstChainId;\r\n        bytes dstDatas; // IntentDstData[]\r\n        uint256 expires;\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing a message used in cross-chain bridging.\r\n     */\r\n    struct BridgeData {\r\n        bytes32 intentId; // protocol bridge message data\r\n        bytes intentData; // bridged protocol intent information\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing a message used in cross-chain bridging.\r\n     */\r\n    struct BridgeMsgData {\r\n        bool isBatch;\r\n        bytes bridgeData; // bridge data information\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about a liquidity pool.\r\n     */\r\n    struct PoolData {\r\n        uint64 poolId; // Unique identifier for the pool.\r\n        address underlyingToken; // Address of the underlying token for the pool.\r\n        address supplyToken; // Address of the supply token for the pool.\r\n        uint256 unclaimedProfit; // Accumulated unclaimed profit in the pool.\r\n        uint256 currentIndex; // Current index used for incentive calculations.\r\n        // uint256 lastUpdateTimestamp; // Timestamp of the last update.\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about a user's interaction with a pool.\r\n     */\r\n    struct UserData {\r\n        uint256 currentPoolIndex; // User's current index in the pool.\r\n        // uint256 lastUpdateTimestamp; // Timestamp of the last update.\r\n    }\r\n    \r\n    // BELOW TYPES ARE NOT BEING USED FOR NOW\r\n\r\n    /**\r\n     * @dev enum representing intent token type.\r\n     */\r\n    enum IntentTokenType {\r\n        ERC20,\r\n        ERC1155,\r\n        ERC721\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about the chain.\r\n     */\r\n    struct ChainData {\r\n        address protocolAddress;\r\n        uint64 ccipChainselector;\r\n        uint32 subnetId;\r\n        address middlewareAddress;\r\n    }\r\n}\r\n"
      },
      "contracts/protocol/BondBridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport {IRouterClient} from \"@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol\";\r\nimport {Client} from \"@chainlink/contracts-ccip/contracts/libraries/Client.sol\";\r\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol\";\r\nimport {IERC20} from \"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\r\nimport {SafeERC20} from \"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {DataTypes} from \"../libraries/DataTypes.sol\";\r\nimport {IBondProtocol} from \"../interfaces/IBondProtocol.sol\";\r\n\r\n/// @title - Bond protocol bridge contract\r\ncontract BondBridge is CCIPReceiver, Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // Custom errors to provide more descriptive revert messages.\r\n    error NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees); // Used to make sure contract has enough balance to cover the fees.\r\n    error NothingToWithdraw(); // Used when trying to withdraw Ether but there's nothing to withdraw.\r\n    error FailedToWithdrawEth(address owner, address target, uint256 value); // Used when the withdrawal of Ether fails.\r\n    error DestinationChainNotAllowed(uint64 destinationChainSelector); // Used when the destination chain has not been allowlisted by the contract owner.\r\n    error SourceChainNotAllowed(uint64 sourceChainSelector); // Used when the source chain has not been allowlisted by the contract owner.\r\n    error SenderNotAllowed(address sender); // Used when the sender has not been allowlisted by the contract owner.\r\n    error InvalidReceiverAddress(); // Used when the receiver address is 0.\r\n    error OnlyProtocolIsAllowed(); // only protocol is allowed to send\r\n    error DestinationAddressError();\r\n\r\n    // Event emitted when a message is sent to another chain.\r\n    event MessageSent(\r\n        bytes32 indexed messageId,\r\n        uint64 indexed destinationChainSelector,\r\n        address receiver,\r\n        address feeToken,\r\n        uint256 fees\r\n    );\r\n\r\n    // Event emitted when a message is received from another chain.\r\n    event MessageReceived(\r\n        bytes32 indexed messageId,\r\n        uint64 indexed sourceChainSelector,\r\n        address sender,\r\n        bytes32 intentId,\r\n        address token,\r\n        uint256 tokenAmount\r\n    );\r\n\r\n    bytes32 private s_lastReceivedMessageId; // Store the last received messageId.\r\n    address private s_lastReceivedTokenAddress; // Store the last received token address.\r\n    uint256 private s_lastReceivedTokenAmount; // Store the last received amount.\r\n    DataTypes.BridgeMsgData private s_lastReceivedMsg; // Store the last received text.\r\n\r\n    IBondProtocol public protocol;\r\n\r\n    // Mapping to keep track of allowlisted destination chains.\r\n    mapping(uint64 => bool) public allowlistedDestinationChains;\r\n\r\n    // Mapping to keep track of allowlisted source chains.\r\n    mapping(uint64 => bool) public allowlistedSourceChains;\r\n\r\n    // Mapping to keep track of allowlisted senders.\r\n    mapping(address => bool) public allowlistedSenders;\r\n\r\n    mapping(uint64 chainSelector => address)\r\n        public chainSelectorToBridgeAddress;\r\n\r\n    IERC20 private s_linkToken;\r\n\r\n    /// @notice Constructor initializes the contract with the router address.\r\n    /// @param _router The address of the router contract.\r\n    /// @param _link The address of the link contract.\r\n    /// @param _protocol The address of the protocol contract.\r\n    constructor(\r\n        address _router,\r\n        address _link,\r\n        address _protocol,\r\n        address _initialOwner\r\n    ) CCIPReceiver(_router) Ownable(_initialOwner) {\r\n        s_linkToken = IERC20(_link);\r\n        protocol = IBondProtocol(_protocol);\r\n    }\r\n\r\n    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.\r\n    /// @param _destinationChainSelector The selector of the destination chain.\r\n    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {\r\n        if (!allowlistedDestinationChains[_destinationChainSelector])\r\n            revert DestinationChainNotAllowed(_destinationChainSelector);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier that checks the receiver address is not 0.\r\n    /// @param _receiver The receiver address.\r\n    modifier validateReceiver(address _receiver) {\r\n        if (_receiver == address(0)) revert InvalidReceiverAddress();\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.\r\n    /// @param _sourceChainSelector The selector of the destination chain.\r\n    /// @param _sender The address of the sender.\r\n    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {\r\n        if (!allowlistedSourceChains[_sourceChainSelector])\r\n            revert SourceChainNotAllowed(_sourceChainSelector);\r\n        if (!allowlistedSenders[_sender]) revert SenderNotAllowed(_sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyProtocol() {\r\n        if (msg.sender != address(protocol)) revert OnlyProtocolIsAllowed();\r\n        _;\r\n    }\r\n\r\n    /// @dev Updates the allowlist status of a destination chain for transactions.\r\n    /// @notice This function can only be called by the owner.\r\n    /// @param _destinationChainSelector The selector of the destination chain to be updated.\r\n    /// @param allowed The allowlist status to be set for the destination chain.\r\n    function allowlistDestinationChain(\r\n        uint64 _destinationChainSelector,\r\n        bool allowed\r\n    ) external onlyOwner {\r\n        allowlistedDestinationChains[_destinationChainSelector] = allowed;\r\n    }\r\n\r\n    /// @dev Updates the allowlist status of a source chain\r\n    /// @notice This function can only be called by the owner.\r\n    /// @param _sourceChainSelector The selector of the source chain to be updated.\r\n    /// @param allowed The allowlist status to be set for the source chain.\r\n    function allowlistSourceChain(\r\n        uint64 _sourceChainSelector,\r\n        bool allowed\r\n    ) external onlyOwner {\r\n        allowlistedSourceChains[_sourceChainSelector] = allowed;\r\n    }\r\n\r\n    // function setProtocol(address _protocol) external onlyOwner {\r\n    //     protocol = protocol;\r\n    // }\r\n\r\n    /// @dev Updates the allowlist status of a sender for transactions.\r\n    /// @notice This function can only be called by the owner.\r\n    /// @param _sender The address of the sender to be updated.\r\n    /// @param allowed The allowlist status to be set for the sender.\r\n    // function allowlistSender(address _sender, bool allowed) external onlyOwner {\r\n    //     allowlistedSenders[_sender] = allowed;\r\n    // }\r\n\r\n    /// @notice Sends data and transfer tokens to receiver on the destination chain.\r\n    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\r\n    /// @param _bridgeMsgData The bytes data to be sent.\r\n    /// @param _token token address.\r\n    /// @param _amount token amount.\r\n    /// @param _gasLimit gas limit for ccip\r\n    /// @return fees The ID of the CCIP message that was sent.\r\n    /// @return messageId The ID of the CCIP message that was sent.\r\n    function sendMessage(\r\n        uint64 _destinationChainSelector,\r\n        bytes calldata _bridgeMsgData,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint64 _gasLimit\r\n    )\r\n        external\r\n        onlyProtocol\r\n        onlyAllowlistedDestinationChain(_destinationChainSelector)\r\n        returns (uint256 fees, bytes32 messageId)\r\n    {\r\n        address bridgeAddress = chainSelectorToBridgeAddress[\r\n            _destinationChainSelector\r\n        ];\r\n\r\n        if (bridgeAddress == address(0)) revert DestinationAddressError();\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        // address(linkToken) means fees are paid in LINK\r\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\r\n            bridgeAddress,\r\n            _bridgeMsgData,\r\n            _token,\r\n            _amount,\r\n            address(s_linkToken),\r\n            _gasLimit\r\n        );\r\n\r\n        // Initialize a router client instance to interact with cross-chain router\r\n        IRouterClient router = IRouterClient(this.getRouter());\r\n\r\n        // Get the fee required to send the CCIP message\r\n        fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\r\n\r\n        if (fees > s_linkToken.balanceOf(address(this)))\r\n            revert NotEnoughBalance(s_linkToken.balanceOf(address(this)), fees);\r\n\r\n        // approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK\r\n        s_linkToken.approve(address(router), fees);\r\n\r\n        // approve the Router to spend tokens on contract's behalf. It will spend the amount of the given token\r\n        if (_token != address(0)) {\r\n            IERC20(_token).approve(address(router), _amount);\r\n        }\r\n\r\n        // Send the message through the router and store the returned message ID\r\n        messageId = router.ccipSend(_destinationChainSelector, evm2AnyMessage);\r\n\r\n        // Emit an event with message details\r\n        emit MessageSent(\r\n            messageId,\r\n            _destinationChainSelector,\r\n            msg.sender,\r\n            address(s_linkToken),\r\n            fees\r\n        );\r\n\r\n        // Return the message ID\r\n        return (fees, messageId);\r\n    }\r\n\r\n    function getFees(\r\n        uint64 _destinationChainSelector,\r\n        bytes calldata _bridgeMsgData,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint64 _gasLimit\r\n    ) external view onlyProtocol returns (uint256 _fee) {\r\n        address bridgeAddress = chainSelectorToBridgeAddress[\r\n            _destinationChainSelector\r\n        ];\r\n\r\n        if (bridgeAddress == address(0)) revert DestinationAddressError();\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        // address(linkToken) means fees are paid in LINK\r\n        Client.EVM2AnyMessage memory evm2AnyMessage = _buildCCIPMessage(\r\n            bridgeAddress,\r\n            _bridgeMsgData,\r\n            _token,\r\n            _amount,\r\n            address(s_linkToken),\r\n            _gasLimit\r\n        );\r\n\r\n        // Initialize a router client instance to interact with cross-chain router\r\n        IRouterClient router = IRouterClient(this.getRouter());\r\n\r\n        // Get the fee required to send the CCIP message\r\n        uint256 fees = router.getFee(_destinationChainSelector, evm2AnyMessage);\r\n\r\n        // Return the message ID\r\n        return fees;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the details of the last CCIP received message.\r\n     * @dev This function retrieves the ID, text, token address, and token amount of the last received CCIP message.\r\n     * @return messageId The ID of the last received CCIP message.\r\n     * @return bridgeMsgData The text of the last received CCIP message.\r\n     * @return tokenAddress The address of the token in the last CCIP received message.\r\n     * @return tokenAmount The amount of the token in the last CCIP received message.\r\n     */\r\n    function getLastReceivedMessageDetails()\r\n        public\r\n        view\r\n        returns (\r\n            bytes32 messageId,\r\n            DataTypes.BridgeMsgData memory bridgeMsgData,\r\n            address tokenAddress,\r\n            uint256 tokenAmount\r\n        )\r\n    {\r\n        return (\r\n            s_lastReceivedMessageId,\r\n            s_lastReceivedMsg,\r\n            s_lastReceivedTokenAddress,\r\n            s_lastReceivedTokenAmount\r\n        );\r\n    }\r\n\r\n    /// handle a received message\r\n    function _ccipReceive(\r\n        Client.Any2EVMMessage memory any2EvmMessage\r\n    )\r\n        internal\r\n        override\r\n        onlyAllowlisted(\r\n            any2EvmMessage.sourceChainSelector,\r\n            abi.decode(any2EvmMessage.sender, (address))\r\n        ) // Make sure source chain and sender are allowlisted\r\n    {\r\n        // Expect one token to be transferred at once, but you can transfer several tokens.\r\n        address tokenAddress = any2EvmMessage.destTokenAmounts[0].token;\r\n        uint256 tokenAmount = any2EvmMessage.destTokenAmounts[0].amount;\r\n        DataTypes.BridgeMsgData memory msgData = abi.decode(\r\n            any2EvmMessage.data,\r\n            (DataTypes.BridgeMsgData)\r\n        ); // abi-decoding of the sent text\r\n\r\n        s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\r\n        s_lastReceivedMsg = msgData;\r\n        s_lastReceivedTokenAddress = tokenAddress;\r\n        s_lastReceivedTokenAmount = tokenAmount;\r\n\r\n        if (tokenAddress != address(0) && tokenAmount > 0) {\r\n            IERC20(tokenAddress).transfer(address(protocol), tokenAmount);\r\n        }\r\n\r\n        if (msgData.isBatch == false) {\r\n            DataTypes.BridgeData memory _bridgeData = abi.decode(\r\n                msgData.bridgeData,\r\n                (DataTypes.BridgeData)\r\n            );\r\n            protocol.confirmIncomingIntent(\r\n                _bridgeData.intentData,\r\n                any2EvmMessage.sourceChainSelector\r\n            );\r\n        } else {\r\n            DataTypes.BridgeData[] memory _bridgeDatas = abi.decode(\r\n                msgData.bridgeData,\r\n                (DataTypes.BridgeData[])\r\n            );\r\n            for (uint i = 0; i < _bridgeDatas.length; i++) {\r\n                protocol.confirmIncomingIntent(\r\n                    _bridgeDatas[i].intentData,\r\n                    any2EvmMessage.sourceChainSelector\r\n                );\r\n            }\r\n        }\r\n\r\n        emit MessageReceived(\r\n            any2EvmMessage.messageId,\r\n            any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)\r\n            abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,\r\n            abi.decode(any2EvmMessage.data, (bytes32)),\r\n            any2EvmMessage.destTokenAmounts[0].token,\r\n            any2EvmMessage.destTokenAmounts[0].amount\r\n        );\r\n    }\r\n\r\n    /// @notice Construct a CCIP message.\r\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for programmable tokens transfer.\r\n    /// @param _receiver The address of the receiver.\r\n    /// @param _bridgeMsgData The bytes data to be sent.\r\n    /// @param _token The token to be transferred.\r\n    /// @param _amount The amount of the token to be transferred.\r\n    /// @param _feeTokenAddress The address of the token used for fees. Set address(0) for native gas.\r\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\r\n    function _buildCCIPMessage(\r\n        address _receiver,\r\n        bytes calldata _bridgeMsgData,\r\n        address _token,\r\n        uint256 _amount,\r\n        address _feeTokenAddress,\r\n        uint64 _gasLimit\r\n    ) private pure returns (Client.EVM2AnyMessage memory) {\r\n        // Conditionally set the token amounts based on whether _token is zero address\r\n        Client.EVMTokenAmount[] memory tokenAmounts;\r\n\r\n        if (_token == address(0)) {\r\n            // If token is zero address, create empty array (no tokens to transfer)\r\n            tokenAmounts = new Client.EVMTokenAmount[](0);\r\n        } else {\r\n            // If token is valid, create array with token transfer details\r\n            tokenAmounts = new Client.EVMTokenAmount[](1);\r\n            tokenAmounts[0] = Client.EVMTokenAmount({\r\n                token: _token,\r\n                amount: _amount\r\n            });\r\n        }\r\n\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        return\r\n            Client.EVM2AnyMessage({\r\n                receiver: abi.encode(_receiver), // ABI-encoded receiver address\r\n                data: _bridgeMsgData, // ABI-encoded string\r\n                tokenAmounts: tokenAmounts, // The amount and type of token being transferred (or empty array)\r\n                extraArgs: Client._argsToBytes(\r\n                    Client.GenericExtraArgsV2({\r\n                        gasLimit: _gasLimit,\r\n                        allowOutOfOrderExecution: true\r\n                    })\r\n                ),\r\n                // Set the feeToken to a feeTokenAddress, indicating specific asset will be used for fees\r\n                feeToken: _feeTokenAddress\r\n            });\r\n    }\r\n\r\n    /// @dev Updates the allowlist status of a sender for transactions.\r\n    /// @notice This function can only be called by the owner.\r\n    /// @param _sender The address of the sender to be updated.\r\n    /// @param allowed The allowlist status to be set for the sender.\r\n    function configureAllowListedSender(\r\n        address _sender,\r\n        bool allowed\r\n    ) external onlyOwner {\r\n        allowlistedSenders[_sender] = allowed;\r\n    }\r\n\r\n    function configureDestinationBridgeAddress(\r\n        uint64 _chainSelector,\r\n        address _bridge\r\n    ) external onlyOwner {\r\n        chainSelectorToBridgeAddress[_chainSelector] = _bridge;\r\n    }\r\n\r\n    /// @notice Fallback function to allow the contract to receive Ether.\r\n    /// @dev This function has no function body, making it a default function for receiving Ether.\r\n    /// It is automatically called when Ether is sent to the contract without any data.\r\n    receive() external payable {}\r\n\r\n    /// @notice Allows the contract owner to withdraw the entire balance of Ether from the contract.\r\n    /// @dev This function reverts if there are no funds to withdraw or if the transfer fails.\r\n    /// It should only be callable by the owner of the contract.\r\n    /// @param _beneficiary The address to which the Ether should be sent.\r\n    function withdraw(address _beneficiary) public onlyOwner {\r\n        // Retrieve the balance of this contract\r\n        uint256 amount = address(this).balance;\r\n\r\n        // Revert if there is nothing to withdraw\r\n        if (amount == 0) revert NothingToWithdraw();\r\n\r\n        // Attempt to send the funds, capturing the success status and discarding any return data\r\n        (bool sent, ) = _beneficiary.call{value: amount}(\"\");\r\n\r\n        // Revert if the send failed, with information about the attempted transfer\r\n        if (!sent) revert FailedToWithdrawEth(msg.sender, _beneficiary, amount);\r\n    }\r\n\r\n    /// @notice Allows the owner of the contract to withdraw all tokens of a specific ERC20 token.\r\n    /// @dev This function reverts with a 'NothingToWithdraw' error if there are no tokens to withdraw.\r\n    /// @param _beneficiary The address to which the tokens will be sent.\r\n    /// @param _token The contract address of the ERC20 token to be withdrawn.\r\n    function withdrawToken(\r\n        address _beneficiary,\r\n        address _token\r\n    ) public onlyOwner {\r\n        // Retrieve the balance of this contract\r\n        uint256 amount = IERC20(_token).balanceOf(address(this));\r\n\r\n        // Revert if there is nothing to withdraw\r\n        if (amount == 0) revert NothingToWithdraw();\r\n\r\n        IERC20(_token).safeTransfer(_beneficiary, amount);\r\n    }\r\n}\r\n"
      },
      "node_modules/@chainlink/contracts-ccip/contracts/applications/CCIPReceiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from\n  \"@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(\n    address router\n  ) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId.\n  /// @param interfaceId The interfaceId to check.\n  /// @return true if the interfaceId is supported.\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver.\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// - If this returns false or reverts, only tokens are transferred to the receiver.\n  /// - If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with it at the time of\n  /// execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage.\n  function _ccipReceive(\n    Client.Any2EVMMessage memory message\n  ) internal virtual;\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view virtual returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != getRouter()) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
      },
      "node_modules/@chainlink/contracts-ccip/contracts/interfaces/IAny2EVMMessageReceiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from  the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message. If this reverts, any token transfers also revert.\n  /// The message will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message.\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter.\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external;\n}\n"
      },
      "node_modules/@chainlink/contracts-ccip/contracts/interfaces/IRouterClient.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param destChainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(\n    uint64 destChainSelector\n  ) external view returns (bool supported);\n\n  /// @param destinationChainSelector The destination chainSelector.\n  /// @param message The cross-chain CCIP message including data and/or tokens.\n  /// @return fee returns execution fee for the message.\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain.\n  /// @param destinationChainSelector The destination chain ID.\n  /// @param message The cross-chain CCIP message including data and/or tokens.\n  /// @return messageId The message ID.\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept.\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
      },
      "node_modules/@chainlink/contracts-ccip/contracts/libraries/Client.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains.\n    bytes data; // Data payload.\n    EVMTokenAmount[] tokenAmounts; // Token transfers.\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2).\n  }\n\n  // Tag to indicate only a gas limit. Only usable for EVM as destination chain.\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n\n  // Tag to indicate a gas limit (or dest chain equivalent processing units) and Out Of Order Execution. This tag is\n  // available for multiple chain families. If there is no chain family specific tag, this is the default available\n  // for a chain.\n  // Note: not available for Solana VM based chains.\n  bytes4 public constant GENERIC_EXTRA_ARGS_V2_TAG = 0x181dcf10;\n\n  /// @param gasLimit: gas limit for the callback on the destination chain.\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to\n  /// other messages from the same sender. This value's default varies by chain. On some chains, a particular value is\n  /// enforced, meaning if the expected value is not set, the message request will revert.\n  /// @dev Fully compatible with the previously existing EVMExtraArgsV2.\n  struct GenericExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }\n\n  // Extra args tag for chains that use the Solana VM.\n  bytes4 public constant SVM_EXTRA_ARGS_V1_TAG = 0x1f3b3aba;\n\n  struct SVMExtraArgsV1 {\n    uint32 computeUnits;\n    uint64 accountIsWritableBitmap;\n    bool allowOutOfOrderExecution;\n    bytes32 tokenReceiver;\n    // Additional accounts needed for execution of CCIP receiver. Must be empty if message.receiver is zero.\n    // Token transfer related accounts are specified in the token pool lookup table on SVM.\n    bytes32[] accounts;\n  }\n\n  /// @dev The maximum number of accounts that can be passed in SVMExtraArgs.\n  uint256 public constant SVM_EXTRA_ARGS_MAX_ACCOUNTS = 64;\n\n  /// @dev The expected static payload size of a token transfer when Borsh encoded and submitted to SVM.\n  /// TokenPool extra data and offchain data sizes are dynamic, and should be accounted for separately.\n  uint256 public constant SVM_TOKEN_TRANSFER_DATA_OVERHEAD = (4 + 32) // source_pool\n    + 32 // token_address\n    + 4 // gas_amount\n    + 4 // extra_data overhead\n    + 32 // amount\n    + 32 // size of the token lookup table account\n    + 32 // token-related accounts in the lookup table, over-estimated to 32, typically between 11 - 13\n    + 32 // token account belonging to the token receiver, e.g ATA, not included in the token lookup table\n    + 32 // per-chain token pool config, not included in the token lookup table\n    + 32 // per-chain token billing config, not always included in the token lookup table\n    + 32; // OffRamp pool signer PDA, not included in the token lookup table\n\n  /// @dev Number of overhead accounts needed for message execution on SVM.\n  /// @dev These are message.receiver, and the OffRamp Signer PDA specific to the receiver.\n  uint256 public constant SVM_MESSAGING_ACCOUNTS_OVERHEAD = 2;\n\n  /// @dev The size of each SVM account address in bytes.\n  uint256 public constant SVM_ACCOUNT_BYTE_SIZE = 32;\n\n  function _argsToBytes(\n    GenericExtraArgsV2 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(GENERIC_EXTRA_ARGS_V2_TAG, extraArgs);\n  }\n\n  function _svmArgsToBytes(\n    SVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(SVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
      },
      "node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n   * given ``owner``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
      },
      "node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
      },
      "node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
      },
      "node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
      },
      "node_modules/@chainlink/contracts/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "node_modules/@openzeppelin/contracts/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      }
    }
  }
}