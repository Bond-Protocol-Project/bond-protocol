{
  "_format": "hh3-sol-build-info-1",
  "id": "877fcc1bd445ea5b999a3ed0683fa00ce2e22962",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "publicSourceNameMap": {
    "contracts/protocol/BondProtocol.sol": "contracts/protocol/BondProtocol.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "viaIR": true,
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "forge-std/=npm/forge-std@1.9.4/src/",
        "@account-abstraction/=node_modules/@account-abstraction/",
        "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
        "@chainlink/contracts/=node_modules/@chainlink/contracts/",
        "@chainlink/contracts-ccip/=node_modules/@chainlink/contracts-ccip/",
        "@openzeppelin/contracts-upgradeable/=npm/@openzeppelin/contracts-upgradeable@5.3.0/",
        "npm/@openzeppelin/contracts-upgradeable@5.3.0/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.3.0/"
      ]
    },
    "sources": {
      "contracts/interfaces/IBondBridge.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title IBondProtocol\r\n * @dev Interface of the protocol main contract.\r\n */\r\ninterface IBondBridge {\r\n    /// @notice Sends data and transfer tokens to receiver on the destination chain.\r\n    /// @param _destinationChainSelector The identifier (aka selector) for the destination blockchain.\r\n    /// @param _bridgeMsgData The bytes data to be sent.\r\n    /// @param _token token address.\r\n    /// @param _amount token amount.\r\n    /// @param _gasLimit gas limit for ccip\r\n    function sendMessage(\r\n        uint64 _destinationChainSelector,\r\n        bytes calldata _bridgeMsgData,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint64 _gasLimit\r\n    ) external returns (uint256 _fees, bytes32 messageId);\r\n\r\n    function getFees(\r\n        uint64 _destinationChainSelector,\r\n        bytes calldata _bridgeMsgData,\r\n        address _token,\r\n        uint256 _amount,\r\n        uint64 _gasLimit\r\n    ) external view returns (uint256 _fees);\r\n}\r\n"
      },
      "contracts/interfaces/IBondPool.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\nimport {DataTypes} from \"../libraries/DataTypes.sol\";\r\n\r\n/**\r\n * @title IPool\r\n * @dev Interface of the liquidity pool contract.\r\n */\r\ninterface IBondPool {\r\n    /**\r\n     * @dev Creates a new liquidity pool with the specified parameters, also create the lp token for the pool.\r\n     * @param _poolId Pool ID.\r\n     * @param _underlyingToken Address of the underlying token.\r\n     * @param _supplyTokenName Name of the supply token.\r\n     * @param _supplyTokenSymbol Symbol of the supply token.\r\n     */\r\n    function createPool(\r\n        uint64 _poolId,\r\n        address _underlyingToken,\r\n        string memory _supplyTokenName,\r\n        string memory _supplyTokenSymbol\r\n    ) external returns (DataTypes.PoolData memory _pool);\r\n\r\n    /**\r\n     * @dev Allows a user to supply tokens to the pool and receive supply tokens in return.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to supply.\r\n     * @param _onBehalfOf The address on behalf of which the tokens are supplied.\r\n     */\r\n    function supply(\r\n        uint64 _poolId,\r\n        uint256 _amount,\r\n        address _onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Allows a user to withdraw tokens from the pool.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to withdraw.\r\n     * @param _onBehalfOf The address on behalf of which the tokens are withdrawn.\r\n     */\r\n    function withdraw(\r\n        uint64 _poolId,\r\n        uint256 _amount,\r\n        address _onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Handles the receipt of tokens from the bridge and performs necessary actions.\r\n     * @param _poolId Destination pool ID.\r\n     * @param _fee Fee associated with the transaction.\r\n     */\r\n    function handlePoolIncentive(uint64 _poolId, uint256 _fee) external;\r\n\r\n    /**\r\n     * @dev Updates user incentives for a specific pool.\r\n     * @param _user User address.\r\n     * @param _poolId Pool ID.\r\n     */\r\n    function updateUserIncentives(address _user, uint64 _poolId) external;\r\n\r\n    /**\r\n     * @dev Retrieves data for a specific pool.\r\n     * @param _poolId Pool ID.\r\n     * @return _pool Pool data structure.\r\n     */\r\n    function getPool(\r\n        uint64 _poolId\r\n    ) external view returns (DataTypes.PoolData memory _pool);\r\n\r\n    /**\r\n     * @dev Retrieves user data for a specific account.\r\n     * @param _account User address.\r\n     * @return _user User data structure.\r\n     */\r\n    function getUserData(\r\n        address _account\r\n    ) external view returns (DataTypes.UserData memory _user);\r\n}\r\n"
      },
      "contracts/interfaces/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Interface of the ERC-20 standard as defined in the ERC.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n"
      },
      "contracts/libraries/DataTypes.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.19;\r\n\r\n/**\r\n * @title DataTypes\r\n * @dev Library defining common data structures used in protocol contracts.\r\n */\r\nlibrary DataTypes {\r\n    /**\r\n     * @dev Data structure representing intent destination data to be called by\r\n     *      account in destination chain.\r\n     */\r\n    struct IntentDstData {\r\n        address target;\r\n        uint256 value;\r\n        bytes data;\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about an intent.\r\n     */\r\n    struct IntentData {\r\n        address sender;\r\n        uint64 initChainSenderNonce;\r\n        uint64 initChainId;\r\n        uint64 poolId;\r\n        uint64[] srcChainIds;\r\n        uint256[] srcAmounts;\r\n        uint64 dstChainId;\r\n        bytes dstDatas; // IntentDstData[]\r\n        uint256 expires;\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing a message used in cross-chain bridging.\r\n     */\r\n    struct BridgeData {\r\n        bytes32 intentId; // protocol bridge message data\r\n        bytes intentData; // bridged protocol intent information\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing a message used in cross-chain bridging.\r\n     */\r\n    struct BridgeMsgData {\r\n        bool isBatch;\r\n        bytes bridgeData; // bridge data information\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about a liquidity pool.\r\n     */\r\n    struct PoolData {\r\n        uint64 poolId; // Unique identifier for the pool.\r\n        address underlyingToken; // Address of the underlying token for the pool.\r\n        address supplyToken; // Address of the supply token for the pool.\r\n        uint256 unclaimedProfit; // Accumulated unclaimed profit in the pool.\r\n        uint256 currentIndex; // Current index used for incentive calculations.\r\n        // uint256 lastUpdateTimestamp; // Timestamp of the last update.\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about a user's interaction with a pool.\r\n     */\r\n    struct UserData {\r\n        uint256 currentPoolIndex; // User's current index in the pool.\r\n        // uint256 lastUpdateTimestamp; // Timestamp of the last update.\r\n    }\r\n    \r\n    // BELOW TYPES ARE NOT BEING USED FOR NOW\r\n\r\n    /**\r\n     * @dev enum representing intent token type.\r\n     */\r\n    enum IntentTokenType {\r\n        ERC20,\r\n        ERC1155,\r\n        ERC721\r\n    }\r\n\r\n    /**\r\n     * @dev Data structure representing information about the chain.\r\n     */\r\n    struct ChainData {\r\n        address protocolAddress;\r\n        uint64 ccipChainselector;\r\n        uint32 subnetId;\r\n        address middlewareAddress;\r\n    }\r\n}\r\n"
      },
      "contracts/protocol/BondProtocol.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {DataTypes} from \"../libraries/DataTypes.sol\";\r\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport {IERC20} from \"../interfaces/IERC20.sol\";\r\nimport {IBondBridge} from \"../interfaces/IBondBridge.sol\";\r\nimport {IBondPool} from \"../interfaces/IBondPool.sol\";\r\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\r\n\r\ncontract BondProtocol is Ownable, ReentrancyGuard {\r\n    IBondBridge bridge;\r\n    IBondPool pool;\r\n\r\n    // mappings\r\n    mapping(address user => uint64) public intentNonce;\r\n    mapping(uint64 => uint64) public chainIdToChainSelector;\r\n    mapping(uint64 => uint64) public chainSelectorToChainId;\r\n    mapping(bytes32 intentId => DataTypes.IntentData) private intents;\r\n    mapping(bytes32 intentId => bool) public intentSettled;\r\n    mapping(bytes32 intentId => mapping(uint64 chainId => bool)) srcExecuted;\r\n    mapping(bytes32 => bool) intentExecuted;\r\n    mapping(bytes32 => uint8) srcExecutionCount;\r\n\r\n    // hardcoded, but in the future there will be a mapping for each chain\r\n    uint256 baseProtocolFee = 2e16;\r\n\r\n    // protocol circut breaker switch\r\n    bool public emergencyStop = false;\r\n\r\n    AggregatorV3Interface internal linkUsdAggregator;\r\n\r\n    // events\r\n    event IntentExecutionRequested(bytes32 intentId, address account);\r\n    event IntentSubmitted(\r\n        bytes32 indexed intentId,\r\n        address indexed sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // errors\r\n    error InvalidIntent();\r\n    error InvalidIntentNonce();\r\n    error InvalidIntentSender();\r\n    error InvalidExecutionChain();\r\n    error InvalidIntentExpiryTime();\r\n    error IntentAlreadySubmitted();\r\n    error IntentExpired();\r\n    error InvalidIntentSrcLength();\r\n    error InvalidInitChain();\r\n    error InvalidDstChain();\r\n    error InvalidPoolId();\r\n    error UnsupportedSrcChain();\r\n    error InsufficientFunds();\r\n    error InsufficientAllowance();\r\n    error DuplicateSourceChain();\r\n    error ZeroAddressNotAllowed();\r\n    error ZeroAmountNotAllowed();\r\n    error InvalidChain();\r\n    error TokenTransferError();\r\n    error ProtocolPaused();\r\n    error OnlyBridge();\r\n\r\n    constructor(address _initialOwner) Ownable(_initialOwner) {}\r\n\r\n    modifier onlyBridge() {\r\n        if (msg.sender != address(bridge)) revert OnlyBridge();\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        if (emergencyStop) revert ProtocolPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice This function sends the intent message to every required chain\r\n     * @dev This is the entry function to send an intent request\r\n     * @param _intentData the intent bytes to be executed\r\n     */\r\n    function submitIntent(\r\n        bytes memory _intentData\r\n    ) external nonReentrant whenNotPaused {\r\n        // decode the intent\r\n        DataTypes.IntentData memory _intent = abi.decode(\r\n            _intentData,\r\n            (DataTypes.IntentData)\r\n        );\r\n\r\n        // ensure the intent nonce is valid to prevent replay attack\r\n        if (_intent.initChainSenderNonce != intentNonce[msg.sender])\r\n            revert InvalidIntentNonce();\r\n\r\n        //ensure the intent sender is the contract caller\r\n        if (_intent.sender != msg.sender) revert InvalidIntentSender();\r\n\r\n        //intent source list must not be more than 3\r\n        if (_intent.srcChainIds.length > 3) revert InvalidIntentSrcLength();\r\n\r\n        uint256 _currentBlockTimestamp = block.timestamp;\r\n\r\n        // users pass the expiry time themselves so ensure the intent expiry time is between 30 minutes and 2 hours\r\n        if (\r\n            _intent.expires < _currentBlockTimestamp + (60 * 30) ||\r\n            _intent.expires > _currentBlockTimestamp + (60 * 60 * 2)\r\n        ) revert InvalidIntentExpiryTime();\r\n\r\n        // get the pool data\r\n        // the token address to be interacted with can be retreived from the pool data\r\n        // the poolId is consistent accross chain so this way we can keep track of\r\n        // token addresses across chains\r\n        DataTypes.PoolData memory _poolData = pool.getPool(_intent.poolId);\r\n        if (_poolData.underlyingToken == address(0)) revert InvalidPoolId();\r\n\r\n        // calculate the intent Id from the intent bytes\r\n        bytes32 _intentId = getIntentId(_intentData);\r\n\r\n        //make sure intent hasn't already been submited\r\n        if (intents[_intentId].initChainId != 0)\r\n            revert IntentAlreadySubmitted();\r\n\r\n        uint64 _getChainId = getChainId();\r\n\r\n        // init chain in intent being submited must match the chain it was called from (i.e current chain)\r\n        if (_intent.initChainId != _getChainId) revert InvalidInitChain();\r\n\r\n        // the intent source chain list's length must match the length of the intent source amount\r\n        // there positions in the array defineds the token amount each source chain is required to provide\r\n        if (_intent.srcChainIds.length != _intent.srcAmounts.length)\r\n            revert InvalidIntentSrcLength();\r\n\r\n        uint64 _dstChainSelector = chainIdToChainSelector[_intent.dstChainId];\r\n\r\n        // ensure destination chain is valid and supported\r\n        if (_dstChainSelector == 0 && _intent.dstChainId != _getChainId) revert InvalidDstChain();\r\n\r\n        // store the intent to storage\r\n        intents[_intentId] = _intent;\r\n\r\n        uint256 _srcIdLength = _intent.srcChainIds.length;\r\n\r\n        // we start with _feesInLink = baseProtocolFee  * _srcIdLength which will contain fee to cover destination chain fee and\r\n        // compensation paid to solvers\r\n        // other intent src fees will be added accordingly\r\n        uint256 _feesInLink = baseProtocolFee * _srcIdLength;\r\n\r\n        // prepare interface instance of the underlying token\r\n        IERC20 _token = IERC20(_poolData.underlyingToken);\r\n\r\n        // encode DataTypes.BridgeData\r\n        bytes memory _bridgeData = abi.encode(\r\n            DataTypes.BridgeData(_intentId, _intentData)\r\n        );\r\n\r\n        // encode DataTypes.BridgeMsgData set isBatch to false (not a batched message)\r\n        bytes memory _bridgeMsgData = abi.encode(\r\n            DataTypes.BridgeMsgData(false, _bridgeData)\r\n        );\r\n\r\n        // loop through intent source chains and process accordingly\r\n        for (uint8 i = 0; i < _srcIdLength; ) {\r\n            // ensure source chain is valid by checking if it has been registered as a valid chain\r\n            if (chainIdToChainSelector[_intent.srcChainIds[i]] == 0)\r\n                revert UnsupportedSrcChain();\r\n\r\n            // Validate no zero amounts\r\n            if (_intent.srcAmounts[i] == 0) revert ZeroAmountNotAllowed();\r\n\r\n            // Validate no duplicate source chains\r\n            for (uint8 j = i + 1; j < _srcIdLength; j++) {\r\n                if (_intent.srcChainIds[i] == _intent.srcChainIds[j])\r\n                    revert DuplicateSourceChain();\r\n            }\r\n\r\n            //if the current chain is among the intent source chain list in the iteration\r\n            if (_getChainId == _intent.srcChainIds[i]) {\r\n                // and if the current chain is not the destination chain\r\n                // it means the current chain has to send tokens to the destination chain\r\n                if (_getChainId != _intent.dstChainId) {\r\n                    //  make sure the user has enough token and allowance\r\n                    uint256 _srcAmount = _intent.srcAmounts[i];\r\n                    if (_token.balanceOf(msg.sender) < _srcAmount)\r\n                        revert InsufficientFunds();\r\n                    if (\r\n                        _token.allowance(msg.sender, address(this)) < _srcAmount\r\n                    ) revert InsufficientAllowance();\r\n\r\n                    _token.transferFrom(\r\n                        msg.sender,\r\n                        address(bridge),\r\n                        _srcAmount\r\n                    );\r\n\r\n                    // call the internal function to send token to destination chain\r\n                    (uint256 _bridgeFees, ) = _bridgeIntentMessage(\r\n                        _dstChainSelector,\r\n                        _bridgeMsgData,\r\n                        _poolData.underlyingToken,\r\n                        _srcAmount,\r\n                        400000\r\n                    );\r\n                    // we multiply bridge fee by 2 for now to cover other fees\r\n                    _feesInLink += _bridgeFees * 2;\r\n                } else {\r\n                    // if the current chain is the destination chain and it is also in the intent source chain list\r\n                    // just mark the chain as executed. we are telling the protocol that the current chain has done its part\r\n                    // since the curren chain is the destination chain, it dosent need to bridge funds to itself even if it is\r\n                    // listed in the intent source chain\r\n                    if (_srcIdLength == 1) revert InvalidIntentSrcLength();\r\n                    srcExecutionCount[_intentId]++;\r\n                    srcExecuted[_intentId][_getChainId] = true;\r\n                }\r\n            } else {\r\n                // but if the current chain is not among the source chain list in the iteration, it means it is meant\r\n                // to send a bridge message to the chain. this message will signal the receiving chain to send its token to\r\n                // the destination chain\r\n                (uint256 _bridgeFees, ) = _bridgeIntentMessage(\r\n                    chainIdToChainSelector[_intent.srcChainIds[i]],\r\n                    _bridgeMsgData,\r\n                    address(0),\r\n                    0,\r\n                    400000\r\n                );\r\n                // we multiply bridge fee by 2 for now just to cover the second transaction that goes to destination chain\r\n                _feesInLink += _bridgeFees * 2;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // get fees in selected token using chainlink pricefeed\r\n        (\r\n            ,\r\n            /* uint80 roundId */ int256 answer /*uint256 startedAt*/ /*uint256 updatedAt*/ /*uint80 answeredInRound*/,\r\n            ,\r\n            ,\r\n\r\n        ) = linkUsdAggregator.latestRoundData();\r\n        uint256 _fees = convertLinkToStable(\r\n            _feesInLink,\r\n            answer,\r\n            IERC20(_poolData.underlyingToken).decimals()\r\n        );\r\n\r\n        // make sure there is still enough balance to pay for fees\r\n        if (_token.balanceOf(msg.sender) < _fees) revert InsufficientFunds();\r\n        if (_token.allowance(msg.sender, address(this)) < _fees)\r\n            revert InsufficientAllowance();\r\n        _token.transferFrom(msg.sender, address(this), _fees);\r\n\r\n        intentNonce[msg.sender]++;\r\n\r\n        emit IntentSubmitted(_intentId, msg.sender, _currentBlockTimestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev helper function to send bridge message\r\n     * @param _chainSelector destination chain selector\r\n     * @param _bridgeMsgData the encoded bridge data\r\n     * @param token the token to send\r\n     * @param _amount amount to be sent\r\n     * @param _gasLimit gas limit for ccip\r\n     * @return _fees\r\n     * @return _messageId\r\n     */\r\n    function _bridgeIntentMessage(\r\n        uint64 _chainSelector,\r\n        bytes memory _bridgeMsgData,\r\n        address token,\r\n        uint256 _amount,\r\n        uint64 _gasLimit\r\n    ) internal returns (uint256 _fees, bytes32 _messageId) {\r\n        // bridge intent message to that chain\r\n        return\r\n            bridge.sendMessage(\r\n                _chainSelector,\r\n                _bridgeMsgData,\r\n                token,\r\n                _amount,\r\n                _gasLimit\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice This function just simulates the submitIntent function above and get required fees to process the intent passed\r\n     * @dev simulate submiting intent and get fees\r\n     * @param _intentData the intent bytes data\r\n     */\r\n    function getFees(bytes memory _intentData) external view returns (uint256) {\r\n        DataTypes.IntentData memory _intent = abi.decode(\r\n            _intentData,\r\n            (DataTypes.IntentData)\r\n        );\r\n        if (_intent.initChainSenderNonce != intentNonce[msg.sender])\r\n            revert InvalidIntentNonce();\r\n        if (_intent.sender != msg.sender) revert InvalidIntentSender();\r\n\r\n        DataTypes.PoolData memory _poolData = pool.getPool(_intent.poolId);\r\n        if (_poolData.underlyingToken == address(0)) revert InvalidPoolId();\r\n\r\n        bytes32 _intentId = getIntentId(_intentData);\r\n\r\n        if (intents[_intentId].initChainId != 0)\r\n            revert IntentAlreadySubmitted();\r\n\r\n        uint64 _getChainId = getChainId();\r\n\r\n        // init chain in intent being submited must match the chain it was called (i.e current chain)\r\n        if (_intent.initChainId != _getChainId) revert InvalidInitChain();\r\n\r\n        if (_intent.srcChainIds.length != _intent.srcAmounts.length)\r\n            revert InvalidIntentSrcLength();\r\n\r\n        if (chainIdToChainSelector[_intent.dstChainId] == 0 && _intent.dstChainId != _getChainId)\r\n            revert InvalidDstChain();\r\n\r\n        uint256 _srcIdLength = _intent.srcChainIds.length;\r\n\r\n        // we start with _feesInLink = baseProtocolFee which will contain fee to cover destination chain fee and other fees\r\n        // we start with _feesInLink = baseProtocolFee  * _srcIdLength which will contain fee to cover destination chain fee and\r\n        // compensation paid to solvers\r\n        // other intent src fees will be added accordingly\r\n        uint256 _feesInLink = baseProtocolFee * _srcIdLength;\r\n\r\n        bytes memory _bridgeMsgData = abi.encode(\r\n            DataTypes.BridgeData(_intentId, _intentData)\r\n        );\r\n\r\n        for (uint8 i = 0; i < _srcIdLength; ) {\r\n            // ensure source chain is valid by checking if it has been registered as a valid chain\r\n            if (chainIdToChainSelector[_intent.srcChainIds[i]] == 0)\r\n                revert UnsupportedSrcChain();\r\n\r\n            if (_getChainId == _intent.srcChainIds[i]) {\r\n                if (_getChainId != _intent.dstChainId) {\r\n                    uint256 _srcAmount = _intent.srcAmounts[i];\r\n\r\n                    uint256 _bridgeFees = bridge.getFees(\r\n                        chainIdToChainSelector[_intent.dstChainId],\r\n                        _bridgeMsgData,\r\n                        _poolData.underlyingToken,\r\n                        _srcAmount,\r\n                        400000\r\n                    );\r\n                    // we multiply bridge fee by 2 for now to cover other fees\r\n                    _feesInLink += _bridgeFees * 2;\r\n                }\r\n            } else {\r\n                uint256 _bridgeFees = bridge.getFees(\r\n                    chainIdToChainSelector[_intent.srcChainIds[i]],\r\n                    _bridgeMsgData,\r\n                    address(0),\r\n                    0,\r\n                    400000\r\n                );\r\n                // we multiply bridge fee by 2 for now just to cover the second transaction that goes to destination chain\r\n                _feesInLink += _bridgeFees * 2;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n\r\n        // get fees in selected token using chainlink pricefeed\r\n        (\r\n            ,\r\n            /* uint80 roundId */ int256 answer /*uint256 startedAt*/ /*uint256 updatedAt*/ /*uint80 answeredInRound*/,\r\n            ,\r\n            ,\r\n\r\n        ) = linkUsdAggregator.latestRoundData();\r\n        uint256 _fees = convertLinkToStable(\r\n            _feesInLink,\r\n            answer,\r\n            IERC20(_poolData.underlyingToken).decimals()\r\n        );\r\n\r\n        return _fees;\r\n    }\r\n\r\n    /**\r\n     * @notice This function emits event that notifies solvers to build next required userop\r\n     * @dev This function is called by _ccipReceive from the bridge contract, data is to be consumed by the protocol\r\n     * @param _data this is the CCIP bridged message (DataTypes.BridgeData).\r\n     * @param srcBridgedChainSelector The source chain selector from CCIP\r\n     */\r\n    function confirmIncomingIntent(\r\n        bytes memory _data,\r\n        uint64 srcBridgedChainSelector\r\n    ) external onlyBridge whenNotPaused nonReentrant {\r\n        uint64 _getChainId = getChainId();\r\n\r\n        // temporary intent data storage\r\n        DataTypes.IntentData memory _intent = abi.decode(\r\n            _data,\r\n            (DataTypes.IntentData)\r\n        );\r\n\r\n        bytes32 _intentId = getIntentId(_data);\r\n\r\n        // store intent in storage if it does not exist\r\n        if (intents[_intentId].sender == address(0)) {\r\n            intents[_intentId] = _intent;\r\n        } else {\r\n            // verify that incoming intent belong to intent sender\r\n            if (_intent.sender != intents[_intentId].sender)\r\n                revert InvalidIntent();\r\n        }\r\n\r\n        // convert the chainlink chainselector to real blockchain ID\r\n        uint64 srcBridgedChainId = chainSelectorToChainId[\r\n            srcBridgedChainSelector\r\n        ];\r\n\r\n        // get underlying token\r\n        DataTypes.PoolData memory _poolData = getPool(_intent.poolId);\r\n\r\n        // if current chain is the intent destination chain\r\n        if (_intent.dstChainId == _getChainId) {\r\n            bool srcBridgedChainIsInIntentSrcChains;\r\n            bool currentDestChainIsInIntentSrc;\r\n            // loop through to know if current chain is present in intent source chains list\r\n            for (uint8 i = 0; i < _intent.srcChainIds.length; ) {\r\n                // if source ccip chain is present in intent source chains list\r\n                if (_intent.srcChainIds[i] == srcBridgedChainId) {\r\n                    srcBridgedChainIsInIntentSrcChains = true;\r\n                    // if current chain is the destination chain\r\n                    // and src chain from ccip is in the list of source chains in intent\r\n                    // then it means tokens was sent from that source chain to this chain.\r\n                    // send the token to sender address\r\n\r\n                    // mark the ccip src chain as executed\r\n                    // this means the src chain has fufilled its obligation to fund destination chain\r\n                    srcExecutionCount[_intentId]++;\r\n                    srcExecuted[_intentId][_intent.srcChainIds[i]] = true;\r\n\r\n                    IERC20(_poolData.underlyingToken).transfer(\r\n                        _intent.sender,\r\n                        _intent.srcAmounts[i]\r\n                    );\r\n                }\r\n                // if the current chain which is the destination chain is also in the intent source chain list\r\n                if (_intent.srcChainIds[i] == _getChainId) {\r\n                    currentDestChainIsInIntentSrc = true;\r\n                }\r\n\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n            // if the src chain from ccip is not in intent src chain list then it means\r\n            // bridged message is from init chain and no funds was sent\r\n            // also it means current chain is in the intent src list too, hence the init chain sending the message\r\n            // even if it is the dest chain\r\n            if (srcBridgedChainIsInIntentSrcChains == false) {\r\n                // verify that the current chain is in the intent source chain list if\r\n                // the ccip src chain is not in the intent src list.\r\n                // i.e Just making sure the message was sent because the destination chain is in the intent src list\r\n                if (!currentDestChainIsInIntentSrc) revert InvalidChain();\r\n                // since the call was from the init chain and current chain is destination chain\r\n                // current chain is also in the src list, then mark the current chain as executed\r\n                // because the destination chain will only execute execute the\r\n                // dest data when all source chain has been marked as executed\r\n                srcExecutionCount[_intentId]++;\r\n                srcExecuted[_intentId][_getChainId] = true;\r\n            }\r\n\r\n            // check if executions from src is complete\r\n            // first check if the count is equal to the length of the src chains length\r\n            // we use the count first to save gas, if the count is complete then we loop through the\r\n            // srcExecuted to verify that all chains have settled the destination chain\r\n            if (srcExecutionCount[_intentId] >= _intent.srcChainIds.length) {\r\n                bool allSrcExecuted = true;\r\n                for (uint8 i = 0; i < _intent.srcChainIds.length; ) {\r\n                    if (\r\n                        srcExecuted[_intentId][_intent.srcChainIds[i]] == false\r\n                    ) {\r\n                        allSrcExecuted = false;\r\n                    }\r\n                    unchecked {\r\n                        ++i;\r\n                    }\r\n                }\r\n                // if all src chains have indeed sent funds (i.e executed) to the destination chain then\r\n                // emit event so solvers can build userop to settle destination chain\r\n                if (allSrcExecuted) {\r\n                    emit IntentExecutionRequested(_intentId, _intent.sender);\r\n                }\r\n            }\r\n        } else {\r\n            // if current chain is not the intent destination chain\r\n            // then it is in the intent src chain list\r\n            // emit event so solvers can build userop to settle destination chain\r\n            emit IntentExecutionRequested(_intentId, _intent.sender);\r\n        }\r\n    }\r\n\r\n    function isIntentDstChainFullySettled(\r\n        bytes32 _intentId\r\n    ) external view returns (bool) {\r\n        DataTypes.IntentData memory _intent = intents[_intentId];\r\n        if (_intent.sender == address(0)) revert InvalidIntent();\r\n\r\n        bool isSrcExecutionComplete = true;\r\n\r\n        if (srcExecutionCount[_intentId] >= _intent.srcChainIds.length) {\r\n            for (uint8 i = 0; i < _intent.srcChainIds.length; ) {\r\n                if (srcExecuted[_intentId][_intent.srcChainIds[i]] == false) {\r\n                    isSrcExecutionComplete = false;\r\n                }\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        } else {\r\n            isSrcExecutionComplete = false;\r\n        }\r\n\r\n        return isSrcExecutionComplete;\r\n    }\r\n\r\n    /**\r\n     * @dev This function is called by account to settle intent destination chain (i.e send tokens to destination chain)\r\n     * @param _intentId intent Id to interact with\r\n     * @param _executor this is the solver that built the userOp\r\n     */\r\n    function settleIntentDestChain(\r\n        bytes32 _intentId,\r\n        address _executor\r\n    ) external whenNotPaused nonReentrant {\r\n        DataTypes.IntentData memory _intent = intents[_intentId];\r\n\r\n        // validate intentId\r\n        if (_intent.sender != msg.sender) revert InvalidIntentSender();\r\n        // make sure the intentId is still active\r\n        if (intentExecuted[_intentId] != false) revert IntentAlreadySubmitted();\r\n        if (_intent.expires < block.timestamp) revert IntentExpired();\r\n\r\n        // get amount to send\r\n        uint256 _intentSrcAmount = 0;\r\n        for (uint8 i = 0; i < _intent.srcChainIds.length; ) {\r\n            if (_intent.srcChainIds[i] == block.chainid) {\r\n                _intentSrcAmount = _intent.srcAmounts[i];\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        if (_intentSrcAmount == 0) revert InvalidChain();\r\n\r\n        // get pool data so we can retreive token\r\n        DataTypes.PoolData memory _poolData = getPool(_intent.poolId);\r\n\r\n        // make sure protocol have enough allowance\r\n        if (\r\n            IERC20(_poolData.underlyingToken).allowance(\r\n                msg.sender,\r\n                address(this)\r\n            ) < _intentSrcAmount\r\n        ) revert InsufficientAllowance();\r\n\r\n        if (\r\n            IERC20(_poolData.underlyingToken).balanceOf(msg.sender) <\r\n            _intentSrcAmount\r\n        ) revert InsufficientFunds();\r\n\r\n        IERC20(_poolData.underlyingToken).transferFrom(\r\n            msg.sender,\r\n            address(bridge),\r\n            _intentSrcAmount\r\n        );\r\n\r\n        bytes memory _intentData = abi.encode(_intent);\r\n\r\n        // encode DataTypes.BridgeData\r\n        bytes memory _bridgeData = abi.encode(\r\n            DataTypes.BridgeData(_intentId, _intentData)\r\n        );\r\n\r\n        // encode DataTypes.BridgeMsgData set isBatch to false (not a batched message)\r\n        bytes memory _bridgeMsgData = abi.encode(\r\n            DataTypes.BridgeMsgData(false, _bridgeData)\r\n        );\r\n\r\n        // call the internal function to send token to destination chain\r\n        _bridgeIntentMessage(\r\n            chainIdToChainSelector[_intent.dstChainId],\r\n            _bridgeMsgData,\r\n            _poolData.underlyingToken,\r\n            _intentSrcAmount,\r\n            400000\r\n        );\r\n\r\n        // for now we will just set the intentExecuted to true, later executor will be incentivised\r\n        intentExecuted[_intentId] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev This function is called by account to settle the solver that build the userOp to run the intent destination datas\r\n     * @param _intentId intent Id to interact with\r\n     * @param _executor this is the solver that built the userOp\r\n     */\r\n    function settleIntentDestExecutor(\r\n        bytes32 _intentId,\r\n        address _executor\r\n    ) external whenNotPaused nonReentrant {\r\n        // validate intentId\r\n        if (intents[_intentId].sender != msg.sender)\r\n            revert InvalidIntentSender();\r\n        // make sure the intentId is still active\r\n        if (intentExecuted[_intentId] != false) revert IntentAlreadySubmitted();\r\n        if(intents[_intentId].expires < block.timestamp) revert IntentExpired();\r\n        // for now we will just set the intentExecuted to true, later executor will be incentivised\r\n        intentExecuted[_intentId] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev helper function to check if intent has been used on this chain\r\n     * @param _intentId Intent id to check\r\n     */\r\n    function isIntentExecuted(bytes32 _intentId) external view returns (bool) {\r\n        return intentExecuted[_intentId];\r\n    }\r\n\r\n    /**\r\n     * @dev helper function to check if intent is valid\r\n     * @param _intentId Intent id to check\r\n     */\r\n    function isIntentValid(\r\n        bytes32 _intentId,\r\n        address sender_\r\n    ) external view returns (bool) {\r\n        if (\r\n            intentExecuted[_intentId] == false &&\r\n            intents[_intentId].expires > block.timestamp &&\r\n            intents[_intentId].sender == sender_\r\n        ) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a user to supply tokens to the pool and receive supply tokens in return.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to supply.\r\n     */\r\n    function supply(uint64 _poolId, uint256 _amount) external nonReentrant {\r\n        DataTypes.PoolData memory _pool = pool.getPool(_poolId);\r\n        if (IERC20(_pool.underlyingToken).balanceOf(msg.sender) < _amount)\r\n            revert InsufficientFunds();\r\n        if (\r\n            IERC20(_pool.underlyingToken).allowance(msg.sender, address(this)) <\r\n            _amount\r\n        ) revert InsufficientAllowance();\r\n        IERC20(_pool.underlyingToken).transferFrom(\r\n            msg.sender,\r\n            address(pool),\r\n            _amount\r\n        );\r\n        pool.supply(_poolId, _amount, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows a user to withdraw tokens from the pool.\r\n     * @param _poolId Pool ID.\r\n     * @param _amount Amount of tokens to withdraw.\r\n     */\r\n    function withdraw(uint64 _poolId, uint256 _amount) external nonReentrant {\r\n        DataTypes.PoolData memory _pool = pool.getPool(_poolId);\r\n        if (IERC20(_pool.supplyToken).balanceOf(msg.sender) < _amount)\r\n            revert InsufficientFunds();\r\n        pool.withdraw(_poolId, _amount, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new pool with the specified parameters.\r\n     * @param _poolId Pool ID.\r\n     * @param _underlyingToken Address of the underlying token.\r\n     * @param _supplyTokenName Name of the supply token.\r\n     * @param _supplyTokenSymbol Symbol of the supply token.\r\n     */\r\n    function createPool(\r\n        uint64 _poolId,\r\n        address _underlyingToken,\r\n        string memory _supplyTokenName,\r\n        string memory _supplyTokenSymbol\r\n    ) external onlyOwner nonReentrant returns (DataTypes.PoolData memory) {\r\n        return\r\n            pool.createPool(\r\n                _poolId,\r\n                _underlyingToken,\r\n                _supplyTokenName,\r\n                _supplyTokenSymbol\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves pool data for a given pool ID.\r\n     * @param _poolId Pool ID.\r\n     * @return Pool data structure.\r\n     */\r\n    function getPool(\r\n        uint64 _poolId\r\n    ) public view returns (DataTypes.PoolData memory) {\r\n        return pool.getPool(_poolId);\r\n    }\r\n\r\n    /**\r\n     * @notice Handles incentives to pool.\r\n     * @param _poolId pool ID to handle.\r\n     * @param _fee Fee associated with the transaction.\r\n     */\r\n    function handlePoolIncentive(uint64 _poolId, uint256 _fee) internal {\r\n        pool.handlePoolIncentive(_poolId, _fee);\r\n    }\r\n\r\n    /**\r\n     * @dev Retreive current intent nonce for sender\r\n     * @param _sender the sender to retreive intent nonce for\r\n     */\r\n    function getNonce(address _sender) external view returns (uint64) {\r\n        return intentNonce[_sender];\r\n    }\r\n\r\n    /**\r\n     * @dev retreive intent data\r\n     * @param _intentId intent Id to be retreived\r\n     */\r\n    function getIntent(\r\n        bytes32 _intentId\r\n    ) external view returns (DataTypes.IntentData memory) {\r\n        return intents[_intentId];\r\n    }\r\n\r\n    /**\r\n     * @dev Calcuate intent id from intent bytes\r\n     * @param _intent the intent bytes\r\n     */\r\n    function getIntentId(bytes memory _intent) internal pure returns (bytes32) {\r\n        return keccak256(_intent);\r\n    }\r\n\r\n    /**\r\n     * @dev helper function to get the blockchain Id\r\n     */\r\n    function getChainId() internal view returns (uint64) {\r\n        uint256 chainId = block.chainid;\r\n        return uint64(chainId);\r\n    }\r\n\r\n    /**\r\n     * @dev This function pauses or starts protocol\r\n     * @param _value value of protocol switch\r\n     */\r\n    function emergencyPause(bool _value) external onlyOwner {\r\n        emergencyStop = _value;\r\n    }\r\n\r\n    /**\r\n     * @dev This function maps ccip chain selector to blockchain id\r\n     * @param _chainId blockchain id\r\n     * @param _chainSelector ccip chain selector\r\n     */\r\n    function peerChainIdandChainSelector(\r\n        uint64 _chainId,\r\n        uint64 _chainSelector\r\n    ) external onlyOwner {\r\n        chainIdToChainSelector[_chainId] = _chainSelector;\r\n        chainSelectorToChainId[_chainSelector] = _chainId;\r\n    }\r\n\r\n    function convertLinkToStable(\r\n        uint256 feeInLink, // 18 decimals (LINK)\r\n        int256 linkUsdPrice, // 8 decimals (Chainlink LINK/USD feed)\r\n        uint8 stableTokenDecimals // e.g., 6 for USDC, 18 for DAI\r\n    ) public view returns (uint256) {\r\n        require(linkUsdPrice > 0, \"Invalid price\");\r\n\r\n        // Total decimals after multiplying feeInLink and linkUsdPrice\r\n        uint256 totalDecimals = 18 + linkUsdAggregator.decimals();\r\n\r\n        // Amount to divide by to normalize to target stablecoin decimals\r\n        uint256 decimalAdjustment = totalDecimals - stableTokenDecimals;\r\n\r\n        return (feeInLink * uint256(linkUsdPrice)) / (10 ** decimalAdjustment);\r\n    }\r\n\r\n    /**\r\n     * @dev Admin only function to initailize protocol bridge address\r\n     * @param bridge_ bridge address\r\n     */\r\n    function initializeBridge(address bridge_) external nonReentrant onlyOwner {\r\n        bridge = IBondBridge(bridge_);\r\n    }\r\n\r\n    /**\r\n     * @dev Admin only function to initailize protocol pool address\r\n     * @param pool_ pool address\r\n     */\r\n    function initializePool(address pool_) external nonReentrant onlyOwner {\r\n        pool = IBondPool(pool_);\r\n    }\r\n\r\n    function initializeLinkUsdAggregator(\r\n        address _linkUsdAggregatorAddress\r\n    ) external nonReentrant onlyOwner {\r\n        linkUsdAggregator = AggregatorV3Interface(_linkUsdAggregatorAddress);\r\n    }\r\n}\r\n"
      },
      "node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
      },
      "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "node_modules/@openzeppelin/contracts/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      }
    }
  }
}